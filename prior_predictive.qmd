---
title: "Analyzing the prior predictive distribution for a grid of repulsion parameters"
execute:
  echo: false
  warning: false
  cache: false 
format: 
  html:
    embed-resources: true
    toc: true
    toc-location: left
    page-layout: full
    fig-column: page-right
    fig-width: 25
editor: visual
editor_options: 
  chunk_output_type: console
---

### Load and Source

```{r}

#rm(list = ls())
library(tidyverse)
library(plotly)
library(rdist)
library(patchwork)
library(viridis)
library(salso)
library(bayesmix)
library(combinat)
library(plyr)
library(reshape2)
library(brms)

library(AntMAN)
library(ggsci)
#source("src/full_rep_mix.R")
source("src/log_sdir.R")


```

# Prior Predictive function

```{r}

prior_predictive <- function(N, hyperparameters, n_save, sample_num){

  
 if (is.null(hyperparameters)) {
      
      hyperparameters <- list(
        sigma2_prior_shape = 3,
        sigma2_prior_rate = 2,
        alpha_prior = 0.3,
        gamma = 1,
        zeta = 1, 
        M_prior = 2
      )
      
    }else{
      
      hyperparameter_names <- c(
        "sigma2_prior_shape",
        "sigma2_prior_rate",
        "alpha_prior",
        "gamma",
        "zeta",
        "M_prior"
      )
      
      all_hyperparameters_supplied <- names(hyperparameters) %in% hyperparameter_names
      if(all(all_hyperparameters_supplied)){
        # check values
      }else{
        print(paste0("No value supplied for ", hyperparameter_names[!all_hyperparameters_supplied]))
      }
}  
 
list2env(hyperparameters, envir = .GlobalEnv)  
   
# Storage
alloc_out <- matrix(NA, n_save, N)
mu_out <- vector("list", n_save)
weights_out <- vector("list", n_save)
sigma2_out <- vector("list", n_save)
y_pred_out <- matrix(NA, n_save, N)
M_out <- rep(NA, n_save)
M_a_out <- rep(NA, n_save)
M_na_out <- rep(NA, n_save)
log_acrates_mus <- matrix(0, n_save, 50)
log_acrates_weights <- matrix(0, n_save, 50)
accepts_mus <- matrix(NA, n_save, 50)
accepts_weights <- rep(NA, n_save)
mu_sample_rate <- rep(NA, n_save)

for(iter in 1:n_save){

  # 1. Simulate the number of allocated and non-allcoated components

  #M_a_samp = max(1,rpois(1, M_prior))
  #M_na_samp = max(1,rpois(1, M_prior))
  #M_samp <- M_a_samp + M_na_samp

  M_samp <- max(1,rpois(1, M_prior))
  
  # 2. Simulate the variances

  sigma2s_samp <- 1 / rgamma(M_samp, shape = sigma2_prior_shape, rate = sigma2_prior_rate)

  # 3. Simulate the repulsive locations

  # pairwise differences part of the current locations
  #Sample starting value
  mus_samp <- rnorm(M_samp, 0, 1)
  for(m in 1:sample_num){
    all_log_pwdiff <- apply(as.matrix(rdist(mus_samp)), 1, function(x) sum(zeta * log(abs(x))[!is.infinite(log(abs(x)))]))
    log_demon <- - zeta / 2 * mus_samp^2 + zeta * all_log_pwdiff 
    for(p in 1:M_samp){ 
      # if(!is.na(accepts_mus[iter, p]) & accepts_mus[iter, p] == 1){
      #   next
      # }
      # We use a symmetric normal proposal which cancels in the acceptance rate
      x_prop <- rnorm(1, mean = mus_samp[p] , sd = sqrt(0.1))
      log_numer <-  - zeta / 2 * x_prop^2 + sum(zeta * log(abs(cdist(x_prop, mus_samp[-p])))) 
      log_acrate <- min(log_numer - log_demon[p], 1)
      if(log(runif(1)) < log_acrate){
        mus_samp[p] <-  x_prop
        log_demon[p] <- log_numer
        accepts_mus[iter, p] <- 1
      }else{
        accepts_mus[iter, p] <- 0
      }
      log_acrates_mus[iter,p] <- log_acrate
     
      # if(sum(accepts_mus[iter, 1:p]) == p){
      #   break
      # }
    }
  }
   
   mu_sample_rate[iter] <- p/sum(accepts_mus[iter, 1:p])
  
  # 4. Simulate the repulsive weights
  #if(iter %% 100 == 0)  print(paste0(gamma))
  
  weights_samp <- brms::rdirichlet(1, rep(alpha_prior, M_samp))
  for(m in 1:sample_num){
    #filled_comps <- as.integer(names(table(allocs_samp)))
    alpha_post <- rep(alpha_prior, M_samp)
    #alpha_post[filled_comps] <-  alpha_post[filled_comps] + table(allocs_samp )
    #alpha_post <- c(alpha_post, rep(alpha_prior, M_na_samp))

    log_demon <-  sum(2 * gamma * log(c(rdist(c(weights_samp[-1]))))) 
    w_prop <- brms::rdirichlet(1, alpha_post)
    log_numer <- sum(2 * gamma * log(c(rdist(c(w_prop[-1]))))) 
    log_acrate <- min(log_numer - log_demon, 1)
    if(log(runif(1)) < log_acrate){
      weights_samp <-  w_prop
      accepts_weights[iter] <- 1
      break
    }else{
      accepts_weights[iter] <- 0
    } 
  } 
  
  # 6. Simulate data
  
  pred_alloc <- sample(M_samp, N, prob = weights_samp, replace = TRUE)
  y_pred <- rep(NA, N)
  for(i in 1:N){
    y_pred[i] <- rnorm(1, mean = mus_samp[pred_alloc[i]], sd = sqrt(sigma2s_samp[pred_alloc[i]]))
  }

  gaps <- (1:M_samp)[!((1:M_samp) %in% pred_alloc)]
  M_na_samp <- length(gaps)
  M_a_samp <- M_samp - M_na_samp
  
  # Store draws
  M_out[iter] <- M_samp
  M_a_out[iter] <- M_a_samp
  M_na_out[iter] <- M_na_samp
  alloc_out[iter, ] <- pred_alloc
  mu_out[[iter]] <- mus_samp
  weights_out[[iter]] <- weights_samp
  sigma2_out[[iter]] <- sigma2s_samp
  y_pred_out[iter, ] <- y_pred

  if (iter %% 100 == 0) {
    print(iter)
  }
      
}

  results <- list(alloc_out = alloc_out, mu_out = mu_out, weights_out = weights_out, sigma2_out = sigma2_out,
                  y_pred_out = y_pred_out,
                  M_out = M_out, M_a_out = M_a_out, M_na_out = M_na_out,
                  accepts_weights = accepts_weights, accepts_mus = accepts_mus, mu_sample_rate = mu_sample_rate)
  
  return(results)

}


```

## Run

```{r, echo=FALSE, results = FALSE, message=FALSE}

all_gammas <- c(0, 1, 3)
all_zetas <- c(1)
all_alphas <- c(0.1)
repulsive_grid <- expand.grid(all_gammas, all_zetas, all_alphas)
colnames(repulsive_grid) <- c("gamma", "zeta", "alpha")

set.seed(1)
sigma2_prior_shape <- 3
sigma2_prior_rate <- 3
M_prior <- 5

N <- 1000

all_weights.l <- data.frame()
all_mus.l <- data.frame()
all_sigma2s.l <- data.frame()
all_y_pred.l <- data.frame()
all_s_binder <- matrix(NA, length(all_gammas), N)
all_switched_allocs <- matrix(NA, length(all_gammas), N)
all_M_a.l <- data.frame()
all_M_na.l <- data.frame()
#all_M.l <- data.frame()
all_allocs.l<- data.frame()

for(i in 1:nrow(repulsive_grid)){
#for(i in 1:9){

print(paste0(i))

gamma <- repulsive_grid$gamma[i]
zeta <- repulsive_grid$zeta[i]
alpha_prior <- repulsive_grid$alpha[i]

sample_num <- 20

hyperparameters <- list(sigma2_prior_shape = sigma2_prior_shape, sigma2_prior_rate = sigma2_prior_rate,
                        alpha_prior = alpha_prior,
                        gamma = gamma, zeta = zeta)

# Sample from the prior predictive
n_save = 5e3
results <- prior_predictive(N, hyperparameters, n_save, sample_num)

allocs.l <- data.frame(results$alloc_out)
#allocs.l$number <- 1:N
allocs.l$gamma <- gamma
allocs.l$zeta <- zeta
allocs.l$alpha <- alpha_prior
all_allocs.l <- rbind(all_allocs.l, allocs.l)

y_pred_nout <- results$y_pred_out
y_pred_out.l <- melt(y_pred_nout, varnames = c("iter", "datapoint"))
y_pred_out.l$gamma <- gamma
y_pred_out.l$zeta <- zeta
y_pred_out.l$alpha <- alpha_prior
all_y_pred.l <- rbind(all_y_pred.l, y_pred_out.l)


M_a_out.l <- data.frame(iter = 1:n_save, M_a_out = results$M_a_out)
M_a_out.l$gamma <- gamma
M_a_out.l$zeta <- zeta
M_a_out.l$alpha <- alpha_prior
all_M_a.l <- rbind(all_M_a.l, M_a_out.l)

M_na_out.l <- data.frame(iter = 1:n_save, M_na_out = results$M_na_out)
M_na_out.l$gamma <- gamma
M_na_out.l$zeta <- zeta
M_na_out.l$alpha <- alpha_prior
all_M_na.l <- rbind(all_M_na.l, M_na_out.l)

# Ms <- data.frame(M = results$M_a_out + results$M_na_out)
# Ms$iter <- 1:n_save
# Ms$M_na <- NA
# Ms$M_a <- NA
# for(i in 1:n_save){
#   
#   gaps <- (1:Ms$M[i])[!((1:Ms$M[i])%in% results$alloc_out[i,])]
#   Ms$M_na[i] <- length(gaps)
#   Ms$M_a[i] <- Ms$M[i] - Ms$M_na[i]
#   
# }
# M.l <- melt(Ms, id.vars = c("iter"))
# M.l$gamma <- gamma
# M.l$zeta <- zeta
# M.l$alpha <- alpha_prior
# 
# all_M.l <- rbind(all_M.l, M.l)


weights.w <- data.frame(iter = 1:n_save)
weights.w$min <- NA
weights.w$max <- NA
weights.w$mean <- NA

for(iter in 1:n_save){
  
  weights.w$max[iter] <- max(results$weights_out[[iter]])
  weights.w$min[iter] <- min(results$weights_out[[iter]])
  weights.w$mean[iter] <- mean(results$weights_out[[iter]])
  
}

weights.l <- melt(weights.w, id.vars = c("iter"))
weights.l$gamma <- gamma
weights.l$zeta <- zeta
weights.l$alpha <- alpha_prior
all_weights.l <- rbind(all_weights.l, weights.l)

mus.w <- data.frame(iter = 1:n_save)
mus.w$min <- NA
mus.w$max <- NA
mus.w$mean <- NA

for(iter in 1:n_save){
  
  mus.w$max[iter] <- max(results$mu_out[[iter]])
  mus.w$min[iter] <- min(results$mu_out[[iter]])
  mus.w$mean[iter] <- mean(results$mu_out[[iter]])
  
}

mus.l <- melt(mus.w, id.vars = c("iter"))
mus.l$gamma <- gamma
mus.l$zeta <- zeta
mus.l$alpha <- alpha_prior
all_mus.l <- rbind(all_mus.l, mus.l)



}

Ma_bar <- all_M_a.l%>%
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

Ma_bar <- all_M_a.l

```

```{r}

library(dplyr)
library(ggplot2)

gammas = c(0,1,3)
sample_num <- 1e2
acrates <- matrix(ncol = length(gammas), nrow = sample_num)
colnames(acrates) <- gammas


# Initialize a list to store weights for each gamma
weights_list <- vector("list", length(gammas))
names(weights_list) <- gammas

for(gamma in gammas){
    alpha_prior <- 0.1
    M_samp <- 4
    alpha_post <- rep(alpha_prior, M_samp)
    weights_samp <- brms::rdirichlet(1, rep(alpha_prior, M_samp))
    weights_trace <- matrix(ncol = M_samp, nrow = sample_num)
    
    for(m in 1:sample_num){
        alpha_post <- rep(alpha_prior, M_samp)
        log_demon <-  sum(2 * gamma * log(c(rdist(c(weights_samp[-1]))))) 
        w_prop <- brms::rdirichlet(1, alpha_post)
        log_numer <- sum(2 * gamma * log(c(rdist(c(w_prop[-1]))))) 
        log_acrate <- min(log_numer - log_demon, 1)
        acrates[m, which(gamma == gammas)] <- exp(log_acrate)
        
        # Save the current weights
        weights_trace[m, ] <- weights_samp
        
        if(log(runif(1)) < log_acrate){
            weights_samp <-  w_prop
        }


        pred_alloc <- sample(M_samp, N, prob = weights_samp, replace = TRUE)
        y_pred <- rep(NA, N)
        for(i in 1:N){
        y_pred[i] <- rnorm(1, mean = mus_samp[pred_alloc[i]], sd = sqrt(sigma2s_samp[pred_alloc[i]]))
        }

        gaps <- (1:M_samp)[!((1:M_samp) %in% pred_alloc)]
        M_na_samp <- length(gaps)
        M_a_samp <- M_samp - M_na_samp
        }
    
    # Store the weights trace for the current gamma
    weights_list[[as.character(gamma)]] <- weights_trace
}

# Convert acrates to a data frame for easier plotting
acrates_df <- as.data.frame(acrates)
acrates_df$iteration <- 1:sample_num

# Reshape the data for ggplot
acrates_long <- acrates_df %>%
  pivot_longer(cols = -iteration, names_to = "gamma", values_to = "acrate")

# Plot using ggplot
ggplot(acrates_long, aes(x = iteration, y = acrate, color = gamma)) +
  geom_line() +
  geom_hline(data = data.frame(gamma = names(mean_acrates), mean_acrate = mean_acrates),
             aes(yintercept = mean_acrate, color = gamma), linetype = "dashed") +
  geom_text(data = data.frame(gamma = names(mean_acrates), mean_acrate = mean_acrates),
            aes(x = sample_num / 2, y = 2, color = gamma, label = paste("Mean acrate:", round(mean_acrate, 3))),
             vjust = -1) +
            facet_wrap(gamma ~ ., ncol = 1, labeller = label_both) +
  labs(title = "Acceptance Rates Over Iterations",
       x = "Iteration",
       y = "Acceptance Rate") +
  theme_minimal()


# Convert weights_list to a data frame for easier plotting
weights_df <- do.call(rbind, lapply(names(weights_list), function(gamma) {
    data.frame(iteration = 1:sample_num, gamma = gamma, weights_list[[gamma]])
}))

# Reshape the data for ggplot
weights_long <- weights_df %>%
  pivot_longer(cols = -c(iteration, gamma), names_to = "weight_index", values_to = "weight_value")

# Plot using ggplot
ggplot(weights_long, aes(x = iteration, y = weight_value, color = weight_index)) +
  geom_line(size = 1) +  # Increase line size for better visibility
  facet_wrap(~ gamma, ncol = 1, labeller = label_both) +
  labs(title = "Trace Plots of Weights Over Iterations",
       x = "Iteration",
       y = "Weight Value") +
  theme_minimal() +
  theme(legend.position = "bottom")  # Move legend to bottom for better visibility


M_a_samp_list <- vector("list", length(gammas))
names(M_a_samp_list) <- gammas

for(gamma in gammas){
    // ... existing code ...

    M_a_samp_trace <- numeric(sample_num)  # Initialize a vector to store M_a_samp

    for(m in 1:sample_num){
        // ... existing code ...

        M_a_samp_trace[m] <- M_a_samp  # Save M_a_samp for the current iteration
    }

    // Store the M_a_samp trace for the current gamma
    M_a_samp_list[[as.character(gamma)]] <- M_a_samp_trace
}

// Convert M_a_samp_list to a data frame for easier plotting
M_a_samp_df <- do.call(rbind, lapply(names(M_a_samp_list), function(gamma) {
    data.frame(iteration = 1:sample_num, gamma = gamma, M_a_samp = M_a_samp_list[[gamma]])
}))

// Plot M_a_samp using ggplot
M_a_samp_plot <- ggplot(M_a_samp_df, aes(x = iteration, y = M_a_samp, color = gamma)) +
  geom_line(size = 1) +
  facet_wrap(~ gamma, ncol = 1, labeller = label_both) +
  labs(title = "Trace Plots of M_a_samp Over Iterations",
       x = "Iteration",
       y = "M_a_samp Value") +
  theme_minimal() +
  theme(legend.position = "bottom")

// Arrange the plots in a single view
library(gridExtra)
grid.arrange(acrates_plot, weights_plot, M_a_samp_plot, ncol = 3)

```





# Results

### M

```{r}

# Ma_trace <- all_M_a.l%>%
#   mutate(colo = (gamma+1)*zeta) %>% 
#   mutate(colo = factor(colo)) %>% 
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   ggplot(aes(x = iter, y =M_a_out, col = colo, fill = colo)) +
#   geom_line() +
#   #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
#   facet_grid(zeta  ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of allocated components") +
#   #theme(legend.position = "none") +
#    xlab("iteration")+
#   ylab(expression(paste(M[a])))+
#   scale_color_npg()

Ma_bar <- all_M_a.l%>%
  #filter(zeta == 0.01) %>%
  #filter(gamma %in% c(0, 5)) %>%
  #mutate(colo = (gamma+1)*zeta) %>%
  #mutate(colo = factor(colo)) %>%
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

# Mna_trace <- all_M_na.l%>%
#   mutate(colo = (gamma+1)*zeta) %>%
#   mutate(colo = factor(colo)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   ggplot(aes(x = iter, y =M_na_out, col = colo, fill = colo)) +
#   geom_line() +
#   #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
#   facet_grid(zeta  ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of non-allocated components") +
#   #theme(legend.position = "none") +
#    xlab("iteration")+
#   ylab(expression(paste(M[na])))+
#   scale_color_npg()

Mna_bar <- all_M_na.l%>%
  #filter(zeta == 0.01) %>%
  # mutate(colo = (gamma+1)*zeta) %>%
  # mutate(colo = factor(colo)) %>%
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_na_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of nonallocated components") +
  theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

#Ma_trace

#Mna_trace

Ma_bar


Mna_bar

```

Traceplots

```{r}


# all_M.l %>% 
#   filter(variable == "M") %>% 
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   ggplot(aes(x = iter, y = value, col = alpha, fill = alpha)) +
#   geom_line() +
#   facet_grid(zeta ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of all components") +
#   #theme(legend.position = "none")+
#   xlab(expression(paste(M[a])))+
#   scale_fill_npg()
# 
# all_M.l %>% 
#   filter(variable == "M_a") %>% 
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   ggplot(aes(x = iter, y = value, col = alpha, fill = alpha)) +
#   geom_line() +
#   facet_grid(zeta ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of allocated components") +
#   #theme(legend.position = "none")+
#   xlab(expression(paste(M[a])))+
#   scale_fill_npg()
# 
# all_M.l %>% 
#   filter(variable == "M_na") %>% 
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   ggplot(aes(x = iter, y = value, col = alpha, fill = alpha)) +
#   geom_line() +
#   facet_grid(zeta ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of nonallocated components") +
#   #theme(legend.position = "none")+
#   xlab(expression(paste(M[a])))+
#   scale_fill_npg()


```

Barplots

```{r}


# all_M.l %>% 
#   filter(variable == "M") %>% 
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   ggplot(aes(x = value, fill = alpha)) +
#   geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
#   facet_grid(zeta  ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of all components") +
#   #theme(legend.position = "none")+
#   xlab(expression(paste(M[a])))+
#   scale_fill_npg()
# 
# all_M.l %>% 
#   filter(variable == "M_a") %>% 
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   ggplot(aes(x = value, fill = alpha)) +
#   geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
#   facet_grid(zeta  ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of allocated components") +
#   #theme(legend.position = "none")+
#   xlab(expression(paste(M[a])))+
#   scale_fill_npg()
# 
# all_M.l %>% 
#   filter(variable == "M_na") %>% 
#   mutate(gamma = factor(gamma)) %>%
#   mutate(zeta = factor(zeta)) %>%
#   mutate(alpha = factor(alpha)) %>%
#   ggplot(aes(x = value, fill = alpha)) +
#   geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
#   facet_grid(zeta  ~ gamma, scales = "free_y") +
#   ggtitle("Posterior of nonallocated components") +
#   #theme(legend.position = "none")+
#   xlab(expression(paste(M[a])))+
#   scale_fill_npg()


```

# Weights

```{r}

all_weights.l %>% 
  filter(variable == "min") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, after_stat(density), fill = alpha)) +
  geom_histogram(binwidth = 0.1, position = "dodge2") + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the minimum weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_weights.l %>% 
  filter(variable == "max") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, fill = alpha)) +
  geom_histogram(binwidth = 0.1, position = "dodge2", aes(y = after_stat(density))) + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the maximum weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_weights.l %>% 
  filter(variable == "mean") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, fill = alpha)) +
  geom_histogram(binwidth = 0.1, position = "dodge2", aes(y = after_stat(density))) + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the average weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

# Mus

```{r}

all_mus.l %>% 
  filter(variable == "min") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, after_stat(density), fill = alpha)) +
  geom_histogram(binwidth = 1, position = "dodge2") + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the minimum means") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_mus.l %>% 
  filter(variable == "max") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, fill = alpha)) +
  geom_histogram(binwidth = 1, position = "dodge2", aes(y = after_stat(density))) + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the maximum means") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_mus.l %>% 
  filter(variable == "mean") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, fill = alpha)) +
  geom_histogram(binwidth = 1, position = "dodge2", aes(y = after_stat(density))) + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the average means") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

### Predictive density

```{r}

#results$y_pred_out

plot(density(apply(results$y_pred_out, 1, mean), bw = 0.1))

#y_pred.gg <-
all_y_pred.l %>%
  filter(iter == n_save) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = value, col = alpha, fill = alpha)) +
  geom_density(alpha = 0.4, bw = 1) +
  #facet_wrap(zeta + gamma ~., scales = "free_y") +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  scale_color_npg() +
  scale_fill_npg()


all_y_pred.l %>%
  filter(iter == 10) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = value, col = alpha, fill = alpha)) +
  geom_density(alpha = 0.4, bw = 1) +
  #facet_wrap(zeta + gamma ~., scales = "free_y") +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  scale_color_npg() +
  scale_fill_npg()

```

# Different method:

Here we try simulating from the prior predictive by first fixing the number of components and afterwards weighting them according to the prior.

The prior on M is a shifted Poisson distribution with the following density:

```{r}

shifted_poisson <- function(x, lambda){
  
  (exp(-lambda) * lambda^(x - 1)) / gamma(x)
  
}

# vectorized form:

v_shifted_poisson <- Vectorize(shifted_poisson, "x")

```

Plot it:

```{r}

par(mfrow=c(2, 1))
x <- 1:20
plot(x, shifted_poisson(x, lambda = 1), type = 'h',  lwd=10)
for(lambda in 2:5){
  
  lines(x, shifted_poisson(x, lambda = lambda), type = 'h', col = lambda,  lwd=10, beside = T)

}

legend("topright", legend= paste0("Lambda = ", 1:5),
       col=1:5, lty=1, cex=0.99,lwd=5)

plot(x, shifted_poisson(x, lambda = 3), type = 'h',  lwd=10, col = 3)

```

# 2. Prior_predictive_fixed_M

```{r}

prior_predictive_fixed_M <- function(N, hyperparameters, n_save, M){

  
 if (is.null(hyperparameters)) {
      
      hyperparameters <- list(
        sigma2_prior_shape = 3,
        sigma2_prior_rate = 2,
        alpha_prior = 0.3,
        gamma = 1,
        zeta = 1
      )
      
    }else{
      
      hyperparameter_names <- c(
        "sigma2_prior_shape",
        "sigma2_prior_rate",
        "alpha_prior",
        "gamma",
        "zeta"
      )
      
      all_hyperparameters_supplied <- names(hyperparameters) %in% hyperparameter_names
      if(all(all_hyperparameters_supplied)){
        # check values
      }else{
        print(paste0("No value supplied for ", hyperparameter_names[!all_hyperparameters_supplied]))
      }
}  
 
list2env(hyperparameters, envir = .GlobalEnv)  
   
# Storage
alloc_out <- matrix(NA, n_save, N)
mu_out <- vector("list", n_save)
weights_out <- vector("list", n_save)
sigma2_out <- vector("list", n_save)
y_pred_out <- matrix(NA, n_save, N)
M_a_out <- rep(NA, n_save)
M_na_out <- rep(NA, n_save)

log_acrates_mus <- matrix(0, n_save, 50)
log_acrates_weights <- matrix(0, n_save, 50)
accepts_mus <- matrix(NA, n_save, 50)
accepts_weights <- rep(NA, n_save)
mu_sample_rate <- rep(NA, n_save)

mus_samp <- rnorm(M, 0, 1)
weights_samp <- brms::rdirichlet(1, rep(alpha_prior, M))

for(iter in 1:n_save){

  # 1. Simulate the number of allocated and non-allcoated components- not necessary, fix M

  # 2. Simulate the variances

  sigma2s_samp <- 1 / rgamma(M, shape = sigma2_prior_shape, rate = sigma2_prior_rate)

  # 3. Simulate the repulsive locations

  # pairwise differences part of the current locations
  #Sample starting value
  
  all_log_pwdiff <- apply(as.matrix(rdist(mus_samp)), 1, function(x) sum(zeta * log(abs(x))[!is.infinite(log(abs(x)))]))
  log_demon <- - zeta / 2 * mus_samp^2 + zeta * all_log_pwdiff 
  for(p in 1:M){
    # We use a symmetric normal proposal which cancels in the acceptance rate
    x_prop <- rnorm(1, mean = mus_samp[p] , sd = sqrt(0.1))
    log_numer <-  - zeta / 2 * x_prop^2 + sum(zeta * log(abs(cdist(x_prop, mus_samp[-p])))) 
    log_acrate <- min(log_numer - log_demon[p], 1)
    if(log(runif(1)) < log_acrate){
      mus_samp[p] <-  x_prop
      log_demon[p] <- log_numer
      accepts_mus[iter, p] <- 1
    }else{
      accepts_mus[iter, p] <- 0
    }
    log_acrates_mus[iter,p] <- log_acrate
  
  }

   mu_sample_rate[iter] <- p/sum(accepts_mus[iter, 1:p])
  
  # 4. Simulate the repulsive weights

  log_demon <-  sum(2 * gamma * log(c(rdist(c(weights_samp))))) 
  w_prop <- brms::rdirichlet(1, rep(alpha_prior, M))
  log_numer <- sum(2 * gamma * log(c(rdist(c(w_prop))))) 
  log_acrate <- min(log_numer - log_demon, 1)
  if(log(runif(1)) < log_acrate){
    weights_samp <-  w_prop
    accepts_weights[iter] <- 1
  }else{
    accepts_weights[iter] <- 0
  } 
   
  # 6. Simulate data
  
  pred_alloc <- sample(M, N, prob = weights_samp, replace = TRUE)
  y_pred <- rep(NA, N)
  
  #for(i in 1:N){
  #}

  if(iter == n_save){
    #y_pred <- rnorm(1, mean = mus_samp[pred_alloc[i]], sd = sqrt(sigma2s_samp[pred_alloc[i]]))
    y_pred <- rnorm(N, mean = mus_samp[pred_alloc], sd = sqrt(sigma2s_samp[pred_alloc]))
  }
  
  gaps <- (1:M)[!((1:M) %in% pred_alloc)]
  M_na_samp <- length(gaps)
  M_a_samp <- M - M_na_samp
  
  # Store draws
  #M_out[iter] <- M
  M_a_out[iter] <- M_a_samp
  M_na_out[iter] <- M_na_samp
  alloc_out[iter, ] <- pred_alloc
  mu_out[[iter]] <- mus_samp
  weights_out[[iter]] <- weights_samp
  sigma2_out[[iter]] <- sigma2s_samp
  #y_pred_out[iter, ] <- y_pred

  if (iter %% 100 == 0) {
    print(iter)
  }
      
}

  results <- list(alloc_out = alloc_out, mu_out = mu_out, weights_out = weights_out, sigma2_out = sigma2_out,
                  y_pred = y_pred, #y_pred_out = y_pred_out,
                  #M_out = M_out, 
                  M_a_out = M_a_out, M_na_out = M_na_out,
                  accepts_weights = accepts_weights, accepts_mus = accepts_mus, mu_sample_rate = mu_sample_rate)
  
  return(results)

}


```

### Run

```{r}

#n_save <- 1e3 # 20e3
#n_burn <- n_save / 2
#n_thin <- 1

```

```{r, echo=FALSE, results = FALSE, message=FALSE}

all_gammas <- c(0, 1, 5)
all_zetas <- c(0.01, 0.1, 1)
all_alphas <- c(0.5)

all_gammas <- c(0, 1, 5)
all_zetas <- c(0.01)
all_alphas <- c(0.5)

repulsive_grid <- expand.grid(all_gammas, all_zetas, all_alphas)
colnames(repulsive_grid) <- c("gamma", "zeta", "alpha")

set.seed(1)
sigma2_prior_shape <- 3
sigma2_prior_rate <- 3
M_prior <- 5

N <- 100

all_weights.l <- data.frame()
all_mus.l <- data.frame()
all_sigma2s.l <- data.frame()
all_y_pred.l <- data.frame()
all_s_binder <- matrix(NA, length(all_gammas), N)
all_switched_allocs <- matrix(NA, length(all_gammas), N)
all_M_a.l <- data.frame()
all_M_na.l <- data.frame()
#all_M.l <- data.frame()
all_allocs.l<- data.frame()

for(i in 1:nrow(repulsive_grid)){
#for(i in 1:9){

print(paste0(i))

gamma <- repulsive_grid$gamma[i]
zeta <- repulsive_grid$zeta[i]
alpha_prior <- repulsive_grid$alpha[i]

hyperparameters <- list(sigma2_prior_shape = sigma2_prior_shape, sigma2_prior_rate = sigma2_prior_rate,
                        alpha_prior = alpha_prior,
                        gamma = gamma, zeta = zeta)

# Sample from the prior predictive
M_as <- matrix(NA, n_save, 10)
M_nas <- matrix(NA, n_save, 10)
y_preds <- matrix(NA, n_save, 10)
#allocs <- matrix(NA, n_save, 10)
for(M in 1:10){
  
  results <- prior_predictive_fixed_M(N, hyperparameters, n_save, M = M)
  
  M_as[,M] <- results$M_a_out
  M_nas[,M] <- results$M_na_out
  y_preds[,M] <- results$y_pred
  #allocs[,M] <- results$alloc_out
  
}

poi1_probs <- v_shifted_poisson(1:10, lambda = M_prior)

# Number of draws per chain:

poisson_freq <- round(poi1_probs / (1 / n_save), 0)
poisson_freq_data <- round(poi1_probs / (1 / N), 0)
M_a_est <- c()
M_na_est <- c()
y_pred_est <- c()
for(M in 1:10){
  
  M_a_est <- c(M_a_est, M_as[(n_save - poisson_freq[M]):n_save, M] )
  M_na_est <- c(M_na_est, M_nas[(n_save - poisson_freq[M]):n_save, M] )
  y_pred_est <- c(y_pred_est, y_preds[1:poisson_freq_data[M], M] )
  
}

# allocs.l <- data.frame(results$alloc_out)
# #allocs.l$number <- 1:N
# allocs.l$gamma <- gamma
# allocs.l$zeta <- zeta
# allocs.l$alpha <- alpha_prior
# all_allocs.l <- rbind(all_allocs.l, allocs.l)

#y_pred_nout <- y_pred_est
y_pred_out.l <- data.frame(y_pred_est = y_pred_est) #melt(y_pred_nout, varnames = c("iter", "datapoint"))
y_pred_out.l$gamma <- gamma
y_pred_out.l$zeta <- zeta
y_pred_out.l$alpha <- alpha_prior
all_y_pred.l <- rbind(all_y_pred.l, y_pred_out.l)

M_a_out.l <- data.frame(iter = 1:length(M_a_est), M_a_out = M_a_est)
M_a_out.l$gamma <- gamma
M_a_out.l$zeta <- zeta
M_a_out.l$alpha <- alpha_prior
all_M_a.l <- rbind(all_M_a.l, M_a_out.l)

M_na_out.l <- data.frame(iter = 1:length(M_na_est), M_na_out = M_na_est)
M_na_out.l$gamma <- gamma
M_na_out.l$zeta <- zeta
M_na_out.l$alpha <- alpha_prior
all_M_na.l <- rbind(all_M_na.l, M_na_out.l)

# weights.w <- data.frame(iter = 1:n_save)
# weights.w$min <- NA
# weights.w$max <- NA
# weights.w$mean <- NA
#
# for(iter in 1:n_save){
#   
#   weights.w$max[iter] <- max(results$weights_out[[iter]])
#   weights.w$min[iter] <- min(results$weights_out[[iter]])
#   weights.w$mean[iter] <- mean(results$weights_out[[iter]])
#   
# }
# 
# weights.l <- melt(weights.w, id.vars = c("iter"))
# weights.l$gamma <- gamma
# weights.l$zeta <- zeta
# weights.l$alpha <- alpha_prior
# all_weights.l <- rbind(all_weights.l, weights.l)
# 
# mus.w <- data.frame(iter = 1:n_save)
# mus.w$min <- NA
# mus.w$max <- NA
# mus.w$mean <- NA
# 
# for(iter in 1:n_save){
#   
#   mus.w$max[iter] <- max(results$mu_out[[iter]])
#   mus.w$min[iter] <- min(results$mu_out[[iter]])
#   mus.w$mean[iter] <- mean(results$mu_out[[iter]])
#   
# }
# 
# mus.l <- melt(mus.w, id.vars = c("iter"))
# mus.l$gamma <- gamma
# mus.l$zeta <- zeta
# mus.l$alpha <- alpha_prior
# all_mus.l <- rbind(all_mus.l, mus.l)



}

```

# Results

### M

```{r}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_M_na.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_na_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


Mna_trace <- all_M_na.l%>%
  mutate(colo = (gamma+1)*zeta) %>% 
  mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = iter, y =M_na_out, col = colo, fill = colo)) +
  geom_line() +
  #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of non-allocated components") +
  #theme(legend.position = "none") +
   xlab("iteration")+
  ylab(expression(paste(M[na])))+
  scale_color_npg()



```

### Predictive Density

```{r}

all_y_pred.l %>%
  #filter(iter == 10) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = y_pred_est , col = alpha, fill = alpha)) +
  geom_density(alpha = 0.4, bw = 1) +
  #facet_wrap(zeta + gamma ~., scales = "free_y") +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  scale_color_npg() +
  scale_fill_npg()



```

# Rejection Sampler

Since the starting value of the repulsive weights and locations can change at each iteration, we design a rejection sampler instead of a Metropolis Hastings step to sample from the prior.

### RS for repweights

We choose a standard Dirichlet distribution as proposal distribution and define the constant RM which ensures that our proposal density is always larger than the target. (See Overleaf for derivation)

```{r}


rm <- (dir_norm(alphas) / sdir_norm(alpha, beta, gamma, p - 1)) * prod(c(rdist(c(weights_samp))))^gamma

```

Let's see if we can sample from the Selberg Dirichlet in that way, first for fixed M

```{r}

n_save <- 1e3
M_samp <- 3
weights_out <- matrix(NA, n_save, M_samp)
alpha_prior <- 0.1
gamma = 2
#gamma = 0
for(iter in 1:n_save){
  
  if (iter %% 100 == 0) {
    print(iter)
  }

  accepted <- 0
  while(accepted == 0){
    weights_prop <- c(brms::rdirichlet(1, rep(alpha_prior, M_samp)))
    rm <- (dir_norm(rep(alpha_prior, M_samp)) / sdir_norm(alpha_prior, beta = alpha_prior, gamma, M_samp - 1)) * prod(c(rdist(c(weights_prop))))^(2 *gamma) + 1
    numer <- sdir_2(weights_prop, alpha = alpha_prior, gamma)
    demon <- rm * brms::ddirichlet(weights_prop,rep(alpha_prior, M_samp))
    acrate <- numer / demon
    if(runif(1) < acrate){
      weights_samp <-  weights_prop
      accepted <- 1
    }
    
  } 
  
  weights_out[iter, ] <- weights_samp
  
}

plot(density(weights_out[,1]), col = 1)
lines(density(weights_out[,2]), col = 2)
lines(density(weights_out[,3]), col = 3)


```

### Log

```{r}

n_save <- 1e3
M_samp <- 3
weights_out <- matrix(NA, n_save, M_samp)
alpha_prior <- 1
gamma = 5
gamma = 0
for(iter in 1:n_save){
  
  if (iter %% 100 == 0) {
    print(iter)
  }

  accepted <- 0
  while(accepted == 0){
    weights_prop <- c(brms::rdirichlet(1, rep(alpha_prior, M_samp)))
    log_rm <- log(dir_norm(rep(alpha_prior, M_samp))) - log(sdir_norm(alpha_prior, beta = alpha_prior, gamma, M_samp - 1)) + (2 *gamma) * sum(log(c(rdist(c(weights_prop)))) ) + exp(-40)
    log_numer <- log(sdir_2(weights_prop, alpha = alpha_prior, gamma))
    log_demon <- log_rm + brms::ddirichlet(weights_prop,rep(alpha_prior, M_samp), log = TRUE)
    log_acrate <- log_numer - log_demon
    if(log(runif(1)) < log_acrate){
      weights_samp <-  weights_prop
      accepted <- 1
    }
    
  } 
  
  weights_out[iter, ] <- weights_samp
  
}

plot(density(weights_out[,1]), col = 1)
lines(density(weights_out[,2]), col = 2)
lines(density(weights_out[,3]), col = 3)


```

### RS for repulsive locations

```{r}

n_save <- 1e3
M_samp <- 3
mus_out <- matrix(NA, n_save, M_samp)
zeta = 5
for(iter in 1:n_save){
  
  if (iter %% 100 == 0) {
    print(iter)
  }

  accepted <- 0
  while(accepted == 0){
    
    mus_prop <- rnorm(M_samp, 0, sd = sqrt(1 / zeta))
    
    rm <- (1 / G(M_samp , zeta) / (2 * pi * (1 / zeta))^( - M_samp / 2)) * prod(c(rdist(c(mus_prop))))^(zeta) + 1
    numer <- 1 / G(M_samp , zeta) * prod(c(rdist(c(mus_prop))))^(zeta)
    demon <- rm * (2 * pi * (1 / zeta))^(- M_samp / 2)
    acrate <- numer / demon
    if(runif(1) < acrate){
      mus_samp <-  mus_prop
      accepted <- 1
    }
    
  } 
  
  mus_out[iter, ] <- mus_samp
  
}


```

### Log

```{r}

n_save <- 1e3
M_samp <- 3
mus_out <- matrix(NA, n_save, M_samp)
zeta = 5
for(iter in 1:n_save){
  
  if (iter %% 100 == 0) {
    print(iter)
  }

  accepted <- 0
  while(accepted == 0){
    
    mus_prop <- rnorm(M_samp, 0, sd = sqrt(1 / zeta))
    
    rm <- ((1 / G(M_samp , zeta)) / (2 * pi * (1 / zeta))^( - M_samp / 2)) * prod(c(rdist(c(mus_prop))))^(zeta) + exp(-40)
    
    log_rm <- - log(G(M_samp , zeta)) + (M_samp / 2) * log(2 * pi * (1 / zeta)) + zeta * sum(log((rdist(c(mus_prop))))) + exp(-40)
    log_numer <- - log(G(M_samp , zeta)) + zeta * sum(log((rdist(c(mus_prop)))))
    log_demon <- log_rm - (M_samp / 2) * log(2 * pi * (1 / zeta))
    log_acrate <- log_numer - log_demon
    if(log(runif(1)) < log_acrate){
      mus_samp <-  mus_prop
      accepted <- 1
    }
    
  } 
  
  mus_out[iter, ] <- mus_samp
  
}


```

## Prior predictive using RS

Continue here substituting the rs parts into the function:

```{r}

prior_predictive <- function(N, hyperparameters, n_save,rm_constant){

  
 if (is.null(hyperparameters)) {
      
      hyperparameters <- list(
        sigma2_prior_shape = 3,
        sigma2_prior_rate = 2,
        alpha_prior = 0.3,
        gamma = 1,
        zeta = 1, 
        M_prior = 2
      )
      
    }else{
      
      hyperparameter_names <- c(
        "sigma2_prior_shape",
        "sigma2_prior_rate",
        "alpha_prior",
        "gamma",
        "zeta",
        "M_prior"
      )
      
      all_hyperparameters_supplied <- names(hyperparameters) %in% hyperparameter_names
      if(all(all_hyperparameters_supplied)){
        # check values
      }else{
        print(paste0("No value supplied for ", hyperparameter_names[!all_hyperparameters_supplied]))
      }
}  
 
list2env(hyperparameters, envir = .GlobalEnv)  
   
# Storage
alloc_out <- matrix(NA, n_save, N)
mu_out <- vector("list", n_save)
weights_out <- vector("list", n_save)
sigma2_out <- vector("list", n_save)
y_pred_out <- matrix(NA, n_save, N)
M_out <- rep(NA, n_save)
M_a_out <- rep(NA, n_save)
M_na_out <- rep(NA, n_save)
log_acrates_mus <- matrix(0, n_save, 50)
log_acrates_weights <- matrix(0, n_save, 50)
accepts_mus <- matrix(NA, n_save, 50)
accepts_weights <- rep(NA, n_save)
mu_sample_rate <- rep(NA, n_save)

for(iter in 1:n_save){

  # 1. Simulate the number of allocated and non-allcoated components
  M_samp <- max(1,rpois(1, M_prior))
  
  # fix to 5 to see if there are differences
  #M_samp <- 5
  
  # 2. Simulate the variances

  sigma2s_samp <- 1 / rgamma(M_samp, shape = sigma2_prior_shape, rate = sigma2_prior_rate)

  # 3. Simulate the repulsive locations

  # pairwise differences part of the current locations
  # accepted <- 0
  # while(accepted == 0){
  #   
  #   mus_prop <- rnorm(M_samp, 0, sd = sqrt(1 / zeta))
  #   log_rm <- - log(G(M_samp , zeta)) + (M_samp / 2) * log(2 * pi * (1 / zeta)) + exp(-10)
  #   log_numer <- - log(G(M_samp , zeta)) + zeta * sum(log((rdist(c(mus_prop)))))
  #   log_demon <- log_rm - (M_samp / 2) * log(2 * pi * (1 / zeta))
  #   log_acrate <- log_numer - log_demon
  #   if(log(runif(1)) < log_acrate){
  #     mus_samp <-  mus_prop
  #     accepted <- 1
  #   }
  # } 
  
  # MH step for the locations
  
  mus_samp <- rnorm(M_samp, 0, 1)
  for(m in 1:10){
    all_log_pwdiff <- apply(as.matrix(rdist(mus_samp)), 1, function(x) sum(zeta * log(abs(x))[!is.infinite(log(abs(x)))]))
    log_demon <- - zeta / 2 * mus_samp^2 + zeta * all_log_pwdiff 
    for(p in 1:M_samp){ 
      # if(!is.na(accepts_mus[iter, p]) & accepts_mus[iter, p] == 1){
      #   next
      # }
      # We use a symmetric normal proposal which cancels in the acceptance rate
      x_prop <- rnorm(1, mean = mus_samp[p] , sd = sqrt(0.1))
      log_numer <-  - zeta / 2 * x_prop^2 + sum(zeta * log(abs(cdist(x_prop, mus_samp[-p])))) 
      log_acrate <- min(log_numer - log_demon[p], 1)
      if(log(runif(1)) < log_acrate){
        mus_samp[p] <-  x_prop
        log_demon[p] <- log_numer
        accepts_mus[iter, p] <- 1
      }else{
        accepts_mus[iter, p] <- 0
      }
      log_acrates_mus[iter,p] <- log_acrate
     
      if(sum(accepts_mus[iter, 1:p]) == p){
        break
      }
      
    }
  }
  
  
  
  # 4. Simulate the repulsive weights
  
  # Simulate using Rejection Sampling
  
  # if(M_samp == 1){
  #   weights_samp <- 1
  # }else{
  #   accepted <- 0
  #   while(accepted == 0){
  #     weights_prop <- c(brms::rdirichlet(1, rep(alpha_prior, M_samp)))
  #     #log_rm <- log_dir_norm(rep(alpha_prior, M_samp)) - log_D( M_samp - 1, alpha_prior, alpha_prior, gamma) + log(1)
  #     log_rm <- log( sdir_norm(alpha_prior, alpha_prior, gamma, M_samp - 1)/ dir_norm(rep(alpha_prior, M_samp)) + 1 )
  #     #log_rm <- log_D(M_samp - 1, alpha_prior, alpha_prior, gamma) - log_dir_norm(rep(alpha_prior, M_samp)) + log(10)
  #     log_acrate <- log_rm + log_dir_norm(rep(alpha_prior, M_samp)) - log_D(M_samp - 1, alpha_prior, alpha_prior, gamma) +
  #       2 * gamma * sum(log(c(rdist(weights_prop))) )
  #     #log_numer <- log_sdir_2(weights_prop, alpha_prior, gamma)
  #     #log_demon <- log_rm + brms::ddirichlet(weights_prop,rep(alpha_prior, M_samp), log = TRUE)
  #     #log_acrate <- log_numer - log_demon
  #     if(log(runif(1)) < log_acrate){
  #       weights_samp <-  weights_prop
  #       accepted <- 1
  #     }
  #   }
  # }
  
  
  
  # Simualte by normalization of Selberg Gamma random variables
  
  unnorm_weights_accepts <- rep(NA, M_samp)
  #weights_samp <- brms::rdirichlet(1, rep(alpha_prior, M_samp))
  unnorm_weights_samp <- rgamma(M_samp, alpha_prior, 1)
  all_log_pwdiff <- apply(as.matrix(rdist(unnorm_weights_samp)), 1, function(x) sum(2 * gamma * log(abs( x ))[!is.infinite(log(abs( x )))]  ))
     log_demon <- (rep(alpha_prior, M_samp) - 1) * log(unnorm_weights_samp) - unnorm_weights_samp + all_log_pwdiff
      for(m in 1:10){
        for(p in 1:M_samp){
          x_prop <- exp(rnorm(1, mean = log(unnorm_weights_samp[p]) , sd = 1))
          log_numer <- (alpha_prior - 1) * log(x_prop) - x_prop + sum(2 * gamma * log(abs( cdist(x_prop, unnorm_weights_samp[-p])))) +
             log(x_prop)
          log_acrate <- min(log_numer - log_demon[p] - log(unnorm_weights_samp[p]), 1)
          if(log(runif(1)) < log_acrate){
            unnorm_weights_samp[p] <-  x_prop
            log_demon[p] <- log_numer
            unnorm_weights_accepts[p] <- 1
          }else{
            unnorm_weights_accepts[p] <- 0
          }
        }
        if(sum(unnorm_weights_accepts) == M_samp){
          break
        }
      }
    weights_samp <- unnorm_weights_samp / sum(unnorm_weights_samp)
      
  # 6. Simulate data
  
  pred_alloc <- sample(M_samp, N, prob = weights_samp, replace = TRUE)
  y_pred <- rep(NA, N)
  for(i in 1:N){
    y_pred[i] <- rnorm(1, mean = mus_samp[pred_alloc[i]], sd = sqrt(sigma2s_samp[pred_alloc[i]]))
  }

  gaps <- (1:M_samp)[!((1:M_samp) %in% pred_alloc)]
  M_na_samp <- length(gaps)
  M_a_samp <- M_samp - M_na_samp
  
  # Store draws
  M_out[iter] <- M_samp
  M_a_out[iter] <- M_a_samp
  M_na_out[iter] <- M_na_samp
  alloc_out[iter, ] <- pred_alloc
  mu_out[[iter]] <- mus_samp
  weights_out[[iter]] <- weights_samp
  sigma2_out[[iter]] <- sigma2s_samp
  y_pred_out[iter, ] <- y_pred

  if (iter %% 100 == 0) {
    print(iter)
  }
      
}

  results <- list(alloc_out = alloc_out, mu_out = mu_out, weights_out = weights_out, sigma2_out = sigma2_out,
                  y_pred_out = y_pred_out,
                  M_out = M_out, M_a_out = M_a_out, M_na_out = M_na_out,
                  accepts_weights = accepts_weights, accepts_mus = accepts_mus)
  
  return(results)

}

```

# Run

```{r, echo=FALSE, results = FALSE, message=FALSE}

n_save = 1e3
set.seed(2)

all_gammas <- c(0, 1, 3)
#all_gammas <- c(0, 0.1, 0.5)
all_zetas <- c(0.01, 1, 3)
#all_zetas <- c(0.01)
all_alphas <- c(0.5)
all_alphas <- c(2)
#all_gammas <- c(0)
#all_gammas <- c(0, 5)
#all_zetas <- c(0.01)
#all_zetas <- c(0.01, 5, 20)

#repulsive_grid <- expand.grid(all_gammas, all_zetas)
#colnames(repulsive_grid) <- c("gamma", "zeta")

repulsive_grid <- expand.grid(all_gammas, all_zetas, all_alphas)
colnames(repulsive_grid) <- c("gamma", "zeta", "alpha")


sigma2_prior_shape <- 3
sigma2_prior_rate <- 3
M_prior <- 3

N <- 10

all_weights.l <- data.frame()
all_mus.l <- data.frame()
all_sigma2s.l <- data.frame()
all_y_pred.l <- data.frame()
all_s_binder <- matrix(NA, length(all_gammas), N)
all_switched_allocs <- matrix(NA, length(all_gammas), N)
all_M_a.l <- data.frame()
all_M_na.l <- data.frame()
#all_M.l <- data.frame()
all_allocs.l<- data.frame()

all_weights.ls <- list()

for(i in 1:nrow(repulsive_grid)){
#for(i in 1:9){

print(paste0(i))

gamma <- repulsive_grid$gamma[i]
zeta <- repulsive_grid$zeta[i]
alpha_prior <- repulsive_grid$alpha[i]

hyperparameters <- list(sigma2_prior_shape = sigma2_prior_shape, sigma2_prior_rate = sigma2_prior_rate,
                        alpha_prior = alpha_prior,
                        gamma = gamma, zeta = zeta)

# Sample from the prior predictive

results <- prior_predictive(N, hyperparameters, n_save, rm_constant = exp(-40))


allocs.l <- data.frame(results$alloc_out)
#allocs.l$number <- 1:N
allocs.l$gamma <- gamma
allocs.l$zeta <- zeta
allocs.l$alpha <- alpha_prior
all_allocs.l <- rbind(all_allocs.l, allocs.l)

y_pred_nout <- results$y_pred_out
y_pred_out.l <- melt(y_pred_nout, varnames = c("iter", "datapoint"))
y_pred_out.l$gamma <- gamma
y_pred_out.l$zeta <- zeta
y_pred_out.l$alpha <- alpha_prior
all_y_pred.l <- rbind(all_y_pred.l, y_pred_out.l)

M_a_out.l <- data.frame(iter = 1:n_save, M_a_out = results$M_a_out)
M_a_out.l$gamma <- gamma
M_a_out.l$zeta <- zeta
M_a_out.l$alpha <- alpha_prior
all_M_a.l <- rbind(all_M_a.l, M_a_out.l)

M_na_out.l <- data.frame(iter = 1:n_save, M_na_out = results$M_na_out)
M_na_out.l$gamma <- gamma
M_na_out.l$zeta <- zeta
M_na_out.l$alpha <- alpha_prior
all_M_na.l <- rbind(all_M_na.l, M_na_out.l)


# weights

all_weights.ls[[i]] <- results$weights_out 



# Ms <- data.frame(M = results$M_a_out + results$M_na_out)
# Ms$iter <- 1:n_save
# Ms$M_na <- NA
# Ms$M_a <- NA
# for(i in 1:n_save){
#   
#   gaps <- (1:Ms$M[i])[!((1:Ms$M[i])%in% results$alloc_out[i,])]
#   Ms$M_na[i] <- length(gaps)
#   Ms$M_a[i] <- Ms$M[i] - Ms$M_na[i]
#   
# }
# M.l <- melt(Ms, id.vars = c("iter"))
# M.l$gamma <- gamma
# M.l$zeta <- zeta
# M.l$alpha <- alpha_prior
# 
# all_M.l <- rbind(all_M.l, M.l)


weights.w <- data.frame(iter = 1:n_save)
weights.w$min <- NA
weights.w$max <- NA
weights.w$mean <- NA

for(iter in 1:n_save){
  
  weights.w$max[iter] <- max(results$weights_out[[iter]])
  weights.w$min[iter] <- min(results$weights_out[[iter]])
  weights.w$mean[iter] <- mean(results$weights_out[[iter]])
  
}

weights.l <- melt(weights.w, id.vars = c("iter"))
weights.l$gamma <- gamma
weights.l$zeta <- zeta
weights.l$alpha <- alpha_prior
all_weights.l <- rbind(all_weights.l, weights.l)

mus.w <- data.frame(iter = 1:n_save)
mus.w$min <- NA
mus.w$max <- NA
mus.w$mean <- NA

for(iter in 1:n_save){
  
  mus.w$max[iter] <- max(results$mu_out[[iter]])
  mus.w$min[iter] <- min(results$mu_out[[iter]])
  mus.w$mean[iter] <- mean(results$mu_out[[iter]])
  
}

mus.l <- melt(mus.w, id.vars = c("iter"))
mus.l$gamma <- gamma
mus.l$zeta <- zeta
mus.l$alpha <- alpha_prior
all_mus.l <- rbind(all_mus.l, mus.l)


}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

# Results

### M

```{r}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_M_na.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_na_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of nonallocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


Mna_trace <- all_M_na.l%>%
  mutate(colo = (gamma+1)*zeta) %>% 
  mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = iter, y =M_na_out, col = colo, fill = colo)) +
  geom_line() +
  #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of non-allocated components") +
  #theme(legend.position = "none") +
   xlab("iteration")+
  ylab(expression(paste(M[na])))+
  scale_color_npg()



```

# Weights

```{r}

all_weights.l %>% 
  filter(variable == "min") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, after_stat(density), fill = gamma)) +
  geom_histogram(binwidth = 0.1, position = "dodge2") + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the minimum weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_weights.l %>% 
  filter(variable == "max") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, fill = alpha)) +
  geom_histogram(binwidth = 0.1, position = "dodge2", aes(y = after_stat(density))) + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the maximum weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_weights.l %>% 
  filter(variable == "mean") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, fill = alpha)) +
  geom_histogram(binwidth = 0.1, position = "dodge2", aes(y = after_stat(density))) + 
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the average weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

### Predictive Density

```{r}

all_y_pred.l %>%
  filter(iter == n_save-3) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = value , col = alpha, fill = alpha)) +
  geom_density(alpha = 0.4, bw = 0.2) +
  #facet_wrap(zeta + gamma ~., scales = "free_y") +
  facet_grid(zeta  ~ gamma, scales = "free") +
  scale_color_npg() +
  scale_fill_npg() #+
  #xlim(range(all_y_pred.l$value))
  #xlim(c(-4,4))



```

# Selberg Gamma ARMS:

Here we opt to update the unnormalized weights individually, but instead of using the Metropolis Hastigns method, we use the Adaptive Rejection Metropolis Sampling (ARMS) from the "dlm" package.

```{r}

library(dlm)

y <- arms(c(0.2,.6), function(x) 1,
          function(x) (min(x)>0)*(max(x)<1), 500)
plot(y, main="Uniform in the unit square", asp=1)
polygon(c(0,1,1,0),c(0,0,1,1))


```

For this we code the log of the target density and restrict the support to positive values

```{r}

# unnormalized weights
log_sgam_fc <- function(new_unnorm_weight, rest_unnorm_weights, alpha, gamma){
  
  log_sgam_fc <- (alpha - 1) * log(new_unnorm_weight) - new_unnorm_weight + 2 * gamma * sum(log(cdist(new_unnorm_weight,rest_unnorm_weights)))
  return(log_sgam_fc)
 
}

rest_unnorm_weights <- rgamma(3, 1, 1)

log_sgam_fc(2, rest_unnorm_weights, alpha = 2, gamma = 1)

# repulsive locations

log_ge_fc <- function(new_rep_loc, rest_rep_locs, zeta){
  
  log_ge_fc <-  - (zeta / 2) * new_rep_loc^2 + zeta * sum(log(cdist(new_rep_loc,rest_rep_locs)))

  return(log_ge_fc)
 
}

rest_rep_locs <- rnorm(3, 0, 1)

log_ge_fc(2, rest_rep_locs, zeta = 2)





```

```{r}

# y <- arms(c(1), function(x, alpha = 1, gamma = 2, p = 2)
#    - log_D(p - 1, alpha, beta = alpha, gamma) + (alpha - 1) * sum(log(x)) + 2 * gamma * sum(log(c(rdist(x)))),
#   function(x) x[1] >= 0 && x[1] <= 1 && x[2] >= 0 && x[2] <= 1 && x[1] + x[2] == 1, 5000)
# 
# plot(y)
# 
# w_tilde <- rgamma(3, 1, 1)
# 
# y <- arms(c(1), log_sgam_fc(x, rest_unnorm_weights, alpha = 1, gamma = 2),
#   function(x) x >= 0 , 10)
# 
#+ 2 * gamma * sum(log(cdist(new_unnorm_weight,rest_unnorm_weights)))

#(alpha - 1) * log(x) - x + 2 * gamma * sum(log(cdist(x,rest_unnorm_weights)))
#sum(log(cdist(2, rest_unnorm_weights)))

# unnorm. Weights

y <- arms(2, function(x, rest_unnorm_weights = w_tilde, alpha = 1, gamma = 1)
  (alpha - 1) * log(x) - x + 2 * gamma * sum(log(cdist(2, rest_unnorm_weights))),
  function(x) x >= 0  && x <= 1000, 10)

plot(y)


# without limited support: doe snot work!

y <- arms(2, function(x, rest_unnorm_weights = w_tilde, alpha = 1, gamma = 1)
  (alpha - 1) * log(x) - x + 2 * gamma * sum(log(cdist(2, rest_unnorm_weights))),
  function(x) x > 0 && x < exp(20), 1)

plot(y)

# Repulsive locations

mus <- rnorm(3, 0, 1)

y <- arms(2, function(x, rest_rep_locs = mus, zeta = 1)
  - (zeta / 2) * x^2 + zeta * sum(log(cdist(x,rest_rep_locs))),
  function(x) x >  -exp(15) && x < exp(20), 1)

plot(y)





```

### Testing

```{r}

all_gammas <- c(0, 1, 3)
weights_out <- list()
all_weights <- list()
for(g in 1:length(all_gammas)){
  
  gamma = all_gammas[g]
  print(paste0("starting run with gamma = ",gamma))
  for(iter in 1:1000){
  
    unnorm_weights_samp <- rgamma(M_samp, alpha_prior, 1)
    unnorm_weights_start <- 0.1
  for(p in 1:M_samp){ 
    
    unnorm_weights_samp[p] <- arms(unnorm_weights_start, function(x, rest_unnorm_weights =  unnorm_weights_samp[-p], a = alpha_prior, g = gamma)
    (a - 1) * log(x) - x + 2 * g * sum(log(cdist(x, rest_unnorm_weights))),
    function(x) x > 0 && x < exp(10), 1)
  
  }
  
  weights_samp <- unnorm_weights_samp / sum(unnorm_weights_samp)
  
  weights_out[[iter]] <- weights_samp
  
  }
  
  all_weights[[g]] <- weights_out
}

head(all_weights[[1]])

head(all_weights[[3]])

```

# PP using ARMS

```{r}

prior_predictive <- function(N, hyperparameters, n_save,rep_num){

  
 if (is.null(hyperparameters)) {
      
      hyperparameters <- list(
        sigma2_prior_shape = 3,
        sigma2_prior_rate = 2,
        alpha_prior = 0.3,
        gamma = 1,
        zeta = 1, 
        M_prior = 2
      )
      
    }else{
      
      hyperparameter_names <- c(
        "sigma2_prior_shape",
        "sigma2_prior_rate",
        "alpha_prior",
        "gamma",
        "zeta",
        "M_prior"
      )
      
      all_hyperparameters_supplied <- names(hyperparameters) %in% hyperparameter_names
      if(all(all_hyperparameters_supplied)){
        # check values
      }else{
        print(paste0("No value supplied for ", hyperparameter_names[!all_hyperparameters_supplied]))
      }
}  
 
list2env(hyperparameters, envir = .GlobalEnv)  
   
# Storage
alloc_out <- matrix(NA, n_save, N)
mu_out <- vector("list", n_save)
weights_out <- vector("list", n_save)
sigma2_out <- vector("list", n_save)
y_pred_out <- matrix(NA, n_save, N)
M_out <- rep(NA, n_save)
M_a_out <- rep(NA, n_save)
M_na_out <- rep(NA, n_save)
log_acrates_mus <- matrix(0, n_save, 50)
log_acrates_weights <- matrix(0, n_save, 50)
accepts_mus <- matrix(NA, n_save, 50)
accepts_weights <- rep(NA, n_save)
mu_sample_rate <- rep(NA, n_save)

for(iter in 1:n_save){

  # 1. Simulate the number of allocated and non-allcoated components
  M_samp <- max(1,rpois(1, M_prior))
  
  # fix to 5 to see if there are differences
  #M_samp <- 5

  # 2. Simulate the variances

  sigma2s_samp <- 1 / rgamma(M_samp, shape = sigma2_prior_shape, rate = sigma2_prior_rate)

  # 3. Simulate the repulsive locations
  # ARMS step for the locations
  
  mus_samp <- rnorm(M_samp, 0, 1)
  mu_start <- 0
  for(rn in 1:rep_num){
    for(p in 1:M_samp){ 
        
      mus_samp[p] <- arms(mu_start, function(x, rest_rep_locs = mus_samp[-p], z = zeta)
      - (z / 2) * x^2 + z * sum(log(cdist(x,rest_rep_locs))),
      function(x) x >  -exp(10) && x < exp(10), 1)
      
    }
  }
  # 4. Simulate the repulsive weights
  
  # Simulate by normalization of Selberg Gamma random variables
  
  #unnorm_weights_accepts <- rep(NA, M_samp)
  unnorm_weights_samp <- rgamma(M_samp, alpha_prior, 1)
  unnorm_weights_start <- 0.1
  for(rn in 1:rep_num){
    for(p in 1:M_samp){ 
        
      unnorm_weights_samp[p] <- arms(unnorm_weights_start, function(x, rest_unnorm_weights =  unnorm_weights_samp[-p], a = alpha_prior, g = gamma)
      (a - 1) * log(x) - x + 2 * g * sum(log(cdist(x, rest_unnorm_weights))),
      function(x) x > 0 && x < exp(10), 1)
      
    }
  }
  weights_samp <- unnorm_weights_samp / sum(unnorm_weights_samp)
   
  # 6. Simulate data
  
  pred_alloc <- sample(M_samp, N, prob = weights_samp, replace = TRUE)
  y_pred <- rep(NA, N)
  for(i in 1:N){
    y_pred[i] <- rnorm(1, mean = mus_samp[pred_alloc[i]], sd = sqrt(sigma2s_samp[pred_alloc[i]]))
  }

  gaps <- (1:M_samp)[!((1:M_samp) %in% pred_alloc)]
  M_na_samp <- length(gaps)
  M_a_samp <- M_samp - M_na_samp
  
  # Store draws
  M_out[iter] <- M_samp
  M_a_out[iter] <- M_a_samp
  M_na_out[iter] <- M_na_samp
  alloc_out[iter, ] <- pred_alloc
  mu_out[[iter]] <- mus_samp
  weights_out[[iter]] <- weights_samp
  sigma2_out[[iter]] <- sigma2s_samp
  y_pred_out[iter, ] <- y_pred

  if (iter %% 100 == 0) {
    print(iter)
  }
      
}

  results <- list(alloc_out = alloc_out, mu_out = mu_out, weights_out = weights_out, sigma2_out = sigma2_out,
                  y_pred_out = y_pred_out,
                  M_out = M_out, M_a_out = M_a_out, M_na_out = M_na_out,
                  accepts_weights = accepts_weights, accepts_mus = accepts_mus)
  
  return(results)

}

```

# Run

```{r, echo=FALSE, results = FALSE, message=FALSE}

n_save = 1e3
set.seed(2)

all_gammas <- c(0, 1, 3)
#all_gammas <- c(0, 3, 5)
all_zetas <- c(0.01, 1, 3)
all_zetas <- c(0.01)
all_alphas <- c(0.1, 1)
#all_alphas <- c(2)
#all_gammas <- c(0)
#all_gammas <- c(0, 5)
#all_zetas <- c(0.01)
#all_zetas <- c(0.01, 5, 20)

#repulsive_grid <- expand.grid(all_gammas, all_zetas)
#colnames(repulsive_grid) <- c("gamma", "zeta")

repulsive_grid <- expand.grid(all_gammas, all_zetas, all_alphas)
colnames(repulsive_grid) <- c("gamma", "zeta", "alpha")


sigma2_prior_shape <- 3
sigma2_prior_rate <- 3
M_prior <- 3

N <- 500

all_weights.l <- data.frame()
all_mus.l <- data.frame()
all_sigma2s.l <- data.frame()
all_y_pred.l <- data.frame()
all_s_binder <- matrix(NA, length(all_gammas), N)
all_switched_allocs <- matrix(NA, length(all_gammas), N)
all_M_a.l <- data.frame()
all_M_na.l <- data.frame()
#all_M.l <- data.frame()
all_allocs.l<- data.frame()

all_weights.ls <- list()

for(i in 1:nrow(repulsive_grid)){
#for(i in 1:9){

print(paste0(i))

gamma <- repulsive_grid$gamma[i]
zeta <- repulsive_grid$zeta[i]
alpha_prior <- repulsive_grid$alpha[i]

hyperparameters <- list(sigma2_prior_shape = sigma2_prior_shape, sigma2_prior_rate = sigma2_prior_rate,
                        alpha_prior = alpha_prior,
                        gamma = gamma, zeta = zeta)

# Sample from the prior predictive

results <- prior_predictive(N, hyperparameters, n_save, rep_num = 2)


allocs.l <- data.frame(results$alloc_out)
#allocs.l$number <- 1:N
allocs.l$gamma <- gamma
allocs.l$zeta <- zeta
allocs.l$alpha <- alpha_prior
all_allocs.l <- rbind(all_allocs.l, allocs.l)

y_pred_nout <- results$y_pred_out
y_pred_out.l <- melt(y_pred_nout, varnames = c("iter", "datapoint"))
y_pred_out.l$gamma <- gamma
y_pred_out.l$zeta <- zeta
y_pred_out.l$alpha <- alpha_prior
all_y_pred.l <- rbind(all_y_pred.l, y_pred_out.l)

M_a_out.l <- data.frame(iter = 1:n_save, M_a_out = results$M_a_out)
M_a_out.l$gamma <- gamma
M_a_out.l$zeta <- zeta
M_a_out.l$alpha <- alpha_prior
all_M_a.l <- rbind(all_M_a.l, M_a_out.l)

M_na_out.l <- data.frame(iter = 1:n_save, M_na_out = results$M_na_out)
M_na_out.l$gamma <- gamma
M_na_out.l$zeta <- zeta
M_na_out.l$alpha <- alpha_prior
all_M_na.l <- rbind(all_M_na.l, M_na_out.l)


# weights

all_weights.ls[[i]] <- results$weights_out 



# Ms <- data.frame(M = results$M_a_out + results$M_na_out)
# Ms$iter <- 1:n_save
# Ms$M_na <- NA
# Ms$M_a <- NA
# for(i in 1:n_save){
#   
#   gaps <- (1:Ms$M[i])[!((1:Ms$M[i])%in% results$alloc_out[i,])]
#   Ms$M_na[i] <- length(gaps)
#   Ms$M_a[i] <- Ms$M[i] - Ms$M_na[i]
#   
# }
# M.l <- melt(Ms, id.vars = c("iter"))
# M.l$gamma <- gamma
# M.l$zeta <- zeta
# M.l$alpha <- alpha_prior
# 
# all_M.l <- rbind(all_M.l, M.l)


weights.w <- data.frame(iter = 1:n_save)
weights.w$min <- NA
weights.w$max <- NA
weights.w$mean <- NA

for(iter in 1:n_save){
  
  weights.w$max[iter] <- max(results$weights_out[[iter]])
  weights.w$min[iter] <- min(results$weights_out[[iter]])
  weights.w$mean[iter] <- mean(results$weights_out[[iter]])
  
}

weights.l <- melt(weights.w, id.vars = c("iter"))
weights.l$gamma <- gamma
weights.l$zeta <- zeta
weights.l$alpha <- alpha_prior
all_weights.l <- rbind(all_weights.l, weights.l)

mus.w <- data.frame(iter = 1:n_save)
mus.w$min <- NA
mus.w$max <- NA
mus.w$mean <- NA

for(iter in 1:n_save){
  
  mus.w$max[iter] <- max(results$mu_out[[iter]])
  mus.w$min[iter] <- min(results$mu_out[[iter]])
  mus.w$mean[iter] <- mean(results$mu_out[[iter]])
  
}

mus.l <- melt(mus.w, id.vars = c("iter"))
mus.l$gamma <- gamma
mus.l$zeta <- zeta
mus.l$alpha <- alpha_prior
all_mus.l <- rbind(all_mus.l, mus.l)


}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

# Results

### M

```{r}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_M_na.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_na_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of nonallocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


Mna_trace <- all_M_na.l%>%
  mutate(colo = (gamma+1)*zeta) %>% 
  mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = iter, y =M_na_out, col = colo, fill = colo)) +
  geom_line() +
  #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of non-allocated components") +
  #theme(legend.position = "none") +
   xlab("iteration")+
  ylab(expression(paste(M[na])))+
  scale_color_npg()



```

# Weights

```{r}

all_weights.l %>% 
  filter(variable == "min") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, after_stat(density), fill = gamma)) +
  geom_histogram(binwidth = 0.1, position = "dodge2") + 
  #facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the minimum weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_weights.l %>% 
  filter(variable == "max") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, after_stat(density), fill = gamma)) +
  geom_histogram(binwidth = 0.1, position = "dodge2") + 
  #facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the minimum weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

all_weights.l %>% 
  filter(variable == "mean") %>% 
  mutate(gamma = factor(gamma), zeta = factor(zeta), alpha = factor(alpha)) %>% 
  ggplot(aes(x = value, after_stat(density), fill = gamma)) +
  geom_histogram(binwidth = 0.1, position = "dodge2") + 
  #facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of the minimum weights") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

### Predictive Density

```{r}

all_y_pred.l %>%
  filter(iter == n_save) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = value , col = alpha, fill = alpha)) +
  geom_density(alpha = 0.4, bw = 0.2) +
  #facet_wrap(zeta + gamma ~., scales = "free_y") +
  facet_grid(zeta  ~ gamma, scales = "free") +
  scale_color_npg() +
  scale_fill_npg() #+
  #xlim(range(all_y_pred.l$value))
  #xlim(c(-4,4))



```

```{r}

 all_y_pred.l %>%
  filter(iter %in% c((n_save-100):n_save)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = value , col = alpha, fill = alpha)) +
  geom_density(alpha = 0.4, bw = 0.2) +
  #facet_wrap(zeta + gamma ~., scales = "free_y") +
  facet_grid(zeta  ~ gamma, scales = "free") +
  scale_color_npg() +
  scale_fill_npg()

plot(density(ytmp))

```

# Grid evaluation

We can evaluate the prior predictive density on a grid, in 1d essentially a line.

```{r}

y_line <- seq(-5, 5, by = 0.1)
prior_pred <- matrix(NA, n_save, length(y_line))

for(iter in 1:n_save){
  
  for(i in 1:length(y_line)){
    
    prior_pred[iter, i] <- sum(results$weights_out[[iter]] * dnorm(y_line[i],  results$mu_out[[iter]] , sd = sqrt(results$sigma2_out[[iter]])))
    
  }
  
}


plot(y_line, prior_pred[1,], type = "l")

plot(y_line, prior_pred[2,], type = "l")

plot(y_line, colMeans(prior_pred), type = "l")

```

# Pearson's chi-squared distance

```{r}


prior_predictive <- function(N, hyperparameters, n_save, rep_num){

  
 if (is.null(hyperparameters)) {
      
      hyperparameters <- list(
        sigma2_prior_shape = 3,
        sigma2_prior_rate = 2,
        alpha_prior = 0.3,
        gamma = 1,
        zeta = 1, 
        M_prior = 2, 
        m = 2#round(N /2, 0)
      )
      
    }else{
      
      hyperparameter_names <- c(
        "sigma2_prior_shape",
        "sigma2_prior_rate",
        "alpha_prior",
        "gamma",
        "zeta",
        "M_prior"
      )
      
      all_hyperparameters_supplied <- names(hyperparameters) %in% hyperparameter_names
      if(all(all_hyperparameters_supplied)){
        # check values
      }else{
        print(paste0("No value supplied for ", hyperparameter_names[!all_hyperparameters_supplied]))
      }
}  
 
list2env(hyperparameters, envir = .GlobalEnv)  
   
# Storage
alloc_out <- matrix(NA, n_save, N)
mu_out <- vector("list", n_save)
weights_out <- vector("list", n_save)
sigma2_out <- vector("list", n_save)
y_pred_out <- matrix(NA, n_save, N)
M_out <- rep(NA, n_save)
M_a_out <- rep(NA, n_save)
M_na_out <- rep(NA, n_save)
log_acrates_mus <- matrix(0, n_save, 50)
log_acrates_weights <- matrix(0, n_save, 50)
accepts_mus <- matrix(NA, n_save, 50)
accepts_weights <- rep(NA, n_save)
mu_sample_rate <- rep(NA, n_save)
pcs_dist_out <- rep(NA, n_save)

for(iter in 1:n_save){

  # 1. Simulate the number of allocated and non-allcoated components
  M_samp <- max(1,rpois(1, M_prior))
  
  # fix to 5 to see if there are differences
  #M_samp <- 5
  
  # 2. Simulate the variances

  sigma2s_samp <- 1 / rgamma(M_samp, shape = sigma2_prior_shape, rate = sigma2_prior_rate)

  # 3. Simulate the repulsive locations
  # ARMS step for the locations
  
  mus_samp <- rnorm(M_samp, 0, 1)
  #mu_start <- rep(5, M_samp)
  mu_start <- rnorm(M_samp, -3, sd = 1)
  for(rn in 1:rep_num){
    for(p in 1:M_samp){ 
        
      mus_samp[p] <- arms(mu_start[p], function(x, rest_rep_locs = mus_samp[-p], z = zeta)
      - (z / 2) * x^2 + z * sum(log(cdist(x,rest_rep_locs))),
      #function(x) x >  -exp(10) && x < exp(10), 1)
      function(x) x >  -(10) && x < (10), 1)
    }
    mu_start <- mus_samp
  }
  # 4. Simulate the repulsive weights
  
  # Simulate by normalization of Selberg Gamma random variables
  
  #unnorm_weights_accepts <- rep(NA, M_samp)
  unnorm_weights_samp <- rgamma(M_samp, alpha_prior, 1)
  unnorm_weights_start <- rep(0.1, M_samp)
  for(rn in 1:rep_num){
    for(p in 1:M_samp){ 
        
      unnorm_weights_samp[p] <- arms(unnorm_weights_start[p], function(x, rest_unnorm_weights =  unnorm_weights_samp[-p], a = alpha_prior, g = gamma)
      (a - 1) * log(x) - x + 2 * g * sum(log(cdist(x, rest_unnorm_weights))),
      function(x) x > 0 && x < exp(10), 1)
      
    }
    unnorm_weights_start <- unnorm_weights_samp
      }
    weights_samp <- unnorm_weights_samp / sum(unnorm_weights_samp)
      
  # 6. Simulate data
  
  pred_alloc <- sample(M_samp, N, prob = weights_samp, replace = TRUE)
  y_pred <- rep(NA, N)
  for(i in 1:N){
    y_pred[i] <- rnorm(1, mean = mus_samp[pred_alloc[i]], sd = sqrt(sigma2s_samp[pred_alloc[i]]))
  }

  gaps <- (1:M_samp)[!((1:M_samp) %in% pred_alloc)]
  M_na_samp <- length(gaps)
  M_a_samp <- M_samp - M_na_samp
  
  
  # pearson's chi squared distance
  #1. Partition data into m bins:
  partition <- seq(m, N, by = m)
  y_sort <- sort(y_pred)
  pred_alloc_sort <- pred_alloc[order(y_pred)]
  weights_sort <- weights_samp[order(y_pred)]
  pcs_dist <- 0
  #for(ind in partition){
  for(ind in 1:length(partition)){
    
    start_bin <- (ind - 1) * m + 1
    end_bin <- ind * m
    
    #G_a <- sum(dnorm(y_sort[(ind-1):(ind)], mean = mus_samp[pred_alloc_sort[(ind-1):(ind)]], sd = sqrt(sigma2s_samp[pred_alloc_sort[(ind-1):(ind)]])))
    G_a <- sum(weights_samp[pred_alloc_sort[start_bin:end_bin]] * dnorm(y_sort[start_bin:end_bin], mean = mus_samp[pred_alloc_sort[start_bin:end_bin]], sd = sqrt(sigma2s_samp[pred_alloc_sort[start_bin:end_bin]])))
    pcs_dist <-  pcs_dist + ((m/N) - G_a )^2 / G_a
   
  }
  
  
  # Store draws
  M_out[iter] <- M_samp
  M_a_out[iter] <- M_a_samp
  M_na_out[iter] <- M_na_samp
  alloc_out[iter, ] <- pred_alloc
  mu_out[[iter]] <- mus_samp
  weights_out[[iter]] <- weights_samp
  sigma2_out[[iter]] <- sigma2s_samp
  y_pred_out[iter, ] <- y_pred
  pcs_dist_out[iter] <- pcs_dist
  if (iter %% 100 == 0) {
    print(iter)
  }
      
}

  results <- list(alloc_out = alloc_out, mu_out = mu_out, weights_out = weights_out, sigma2_out = sigma2_out,
                  y_pred_out = y_pred_out,
                  M_out = M_out, M_a_out = M_a_out, M_na_out = M_na_out,
                  pcs_dist_out = pcs_dist_out)
  
  return(results)

}



```

# Run

```{r}


n_save = 1e3
set.seed(2)

all_gammas <- c(0, 1, 3)
all_gammas <- c(0, 3, 5)
all_zetas <- c(0.01, 0.5, 1)
#all_zetas <- c(0.01)
#all_alphas <- c(0.1, 1)
all_alphas <- c(0.5)
#all_gammas <- c(0)
#all_gammas <- c(0, 5)
#all_zetas <- c(0.01)
#all_zetas <- c(0.01, 5, 20)

#repulsive_grid <- expand.grid(all_gammas, all_zetas)
#colnames(repulsive_grid) <- c("gamma", "zeta")

repulsive_grid <- expand.grid(all_gammas, all_zetas, all_alphas)
colnames(repulsive_grid) <- c("gamma", "zeta", "alpha")


sigma2_prior_shape <- 3
sigma2_prior_rate <- 3
M_prior <- 3

N <- 100

all_weights.l <- data.frame()
all_mus.l <- data.frame()
all_sigma2s.l <- data.frame()
all_y_pred.l <- data.frame()
all_s_binder <- matrix(NA, length(all_gammas), N)
all_switched_allocs <- matrix(NA, length(all_gammas), N)
all_M_a.l <- data.frame()
all_M_na.l <- data.frame()
#all_M.l <- data.frame()
all_allocs.l<- data.frame()
all_weights.ls <- list()
all_pcs_dists.l<- data.frame()


for(i in 1:nrow(repulsive_grid)){
#for(i in 1:9){

print(paste0(i))

gamma <- repulsive_grid$gamma[i]
zeta <- repulsive_grid$zeta[i]
alpha_prior <- repulsive_grid$alpha[i]

hyperparameters <- list(sigma2_prior_shape = sigma2_prior_shape, sigma2_prior_rate = sigma2_prior_rate,
                        alpha_prior = alpha_prior,
                        gamma = gamma, zeta = zeta)

# Sample from the prior predictive

results <- prior_predictive(N, hyperparameters, n_save, rep_num = 2)


allocs.l <- data.frame(results$alloc_out)
#allocs.l$number <- 1:N
allocs.l$gamma <- gamma
allocs.l$zeta <- zeta
allocs.l$alpha <- alpha_prior
all_allocs.l <- rbind(all_allocs.l, allocs.l)

y_pred_nout <- results$y_pred_out
y_pred_out.l <- melt(y_pred_nout, varnames = c("iter", "datapoint"))
y_pred_out.l$gamma <- gamma
y_pred_out.l$zeta <- zeta
y_pred_out.l$alpha <- alpha_prior
all_y_pred.l <- rbind(all_y_pred.l, y_pred_out.l)

M_a_out.l <- data.frame(iter = 1:n_save, M_a_out = results$M_a_out)
M_a_out.l$gamma <- gamma
M_a_out.l$zeta <- zeta
M_a_out.l$alpha <- alpha_prior
all_M_a.l <- rbind(all_M_a.l, M_a_out.l)

M_na_out.l <- data.frame(iter = 1:n_save, M_na_out = results$M_na_out)
M_na_out.l$gamma <- gamma
M_na_out.l$zeta <- zeta
M_na_out.l$alpha <- alpha_prior
all_M_na.l <- rbind(all_M_na.l, M_na_out.l)


pcs_dists_out.l <- data.frame(iter = 1:n_save, pcs_dist_out = results$pcs_dist_out)
pcs_dists_out.l$gamma <- gamma
pcs_dists_out.l$zeta <- zeta
pcs_dists_out.l$alpha <- alpha_prior
all_pcs_dists.l <- rbind(all_pcs_dists.l, pcs_dists_out.l)


# weights

all_weights.ls[[i]] <- results$weights_out 



# Ms <- data.frame(M = results$M_a_out + results$M_na_out)
# Ms$iter <- 1:n_save
# Ms$M_na <- NA
# Ms$M_a <- NA
# for(i in 1:n_save){
#   
#   gaps <- (1:Ms$M[i])[!((1:Ms$M[i])%in% results$alloc_out[i,])]
#   Ms$M_na[i] <- length(gaps)
#   Ms$M_a[i] <- Ms$M[i] - Ms$M_na[i]
#   
# }
# M.l <- melt(Ms, id.vars = c("iter"))
# M.l$gamma <- gamma
# M.l$zeta <- zeta
# M.l$alpha <- alpha_prior
# 
# all_M.l <- rbind(all_M.l, M.l)


weights.w <- data.frame(iter = 1:n_save)
weights.w$min <- NA
weights.w$max <- NA
weights.w$mean <- NA

for(iter in 1:n_save){
  
  weights.w$max[iter] <- max(results$weights_out[[iter]])
  weights.w$min[iter] <- min(results$weights_out[[iter]])
  weights.w$mean[iter] <- mean(results$weights_out[[iter]])
  
}

weights.l <- melt(weights.w, id.vars = c("iter"))
weights.l$gamma <- gamma
weights.l$zeta <- zeta
weights.l$alpha <- alpha_prior
all_weights.l <- rbind(all_weights.l, weights.l)

mus.w <- data.frame(iter = 1:n_save)
mus.w$min <- NA
mus.w$max <- NA
mus.w$mean <- NA

for(iter in 1:n_save){
  
  mus.w$max[iter] <- max(results$mu_out[[iter]])
  mus.w$min[iter] <- min(results$mu_out[[iter]])
  mus.w$mean[iter] <- mean(results$mu_out[[iter]])
  
}

mus.l <- melt(mus.w, id.vars = c("iter"))
mus.l$gamma <- gamma
mus.l$zeta <- zeta
mus.l$alpha <- alpha_prior
all_mus.l <- rbind(all_mus.l, mus.l)


}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

# PCS-dist

```{r}


all_pcs_dists.l%>%
  #filter(alpha)
  mutate(colo = (gamma+1)*zeta) %>% 
  mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = iter, y = pcs_dist_out , col = colo, fill = colo)) +
  geom_line() +
  #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(gamma  ~ zeta, scales = "free_y") +
  ggtitle("") +
  #theme(legend.position = "none") +
   xlab("iteration")+
  ylab(expression(paste("Pearson Chi-Squared Dist")))+
  scale_color_npg()


all_pcs_dists.l%>%
  #filter(alpha)
  mutate(colo = (gamma+1)*zeta) %>% 
  mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = iter, y = pcs_dist_out , col = colo, fill = colo)) +
  geom_line() +
  #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(gamma  ~ ., scales = "free_y") +
  ggtitle("") +
  #theme(legend.position = "none") +
   xlab("iteration")+
  ylab(expression(paste("Pearson Chi-Squared Dist")))+
  scale_color_npg()



all_pcs_dists.l%>%
  #filter(alpha)
  mutate(colo = (gamma+1)*zeta) %>% 
  mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = iter, y = pcs_dist_out , col = alpha, fill = alpha)) +
  geom_line() +
  #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(gamma  ~ ., scales = "free_y") +
  ggtitle("") +
  #theme(legend.position = "none") +
  xlab(expression(paste("Pearson Chi-Squared Dist")))+
  scale_color_npg()


# Dens

all_pcs_dists.l %>%
  mutate(colo = (gamma+1)*zeta) %>% 
    mutate(colo = factor(colo)) %>% 
  mutate(gamma = factor(gamma)) %>%
  #filter(alpha == curr_alpha) %>% 
   #mutate(component = as.factor(component), gamma = factor(gamma)) %>%
    ggplot(aes(x = pcs_dist_out, col = gamma, fill = gamma)) +
      geom_density(alpha = 0.4) +
        facet_grid(alpha  ~ ., scales = "free")

all_pcs_dists.l %>%
  mutate(colo = (gamma+1)*zeta) %>% 
    mutate(colo = factor(colo)) %>% 
  mutate(gamma = factor(gamma)) %>%
  #filter(alpha == curr_alpha) %>% 
   #mutate(component = as.factor(component), gamma = factor(gamma)) %>%
    ggplot(aes(x = pcs_dist_out, col = colo, fill = colo)) +
      geom_density(alpha = 0.4) #+
        facet_grid(gamma  ~ zeta, scales = "free")

# Facetted

all_pcs_dists.l %>%
  mutate(colo = (gamma+1)*zeta) %>% 
    mutate(colo = factor(colo)) %>% 
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  #filter(alpha == curr_alpha) %>% 
   #mutate(component = as.factor(component), gamma = factor(gamma)) %>%
    ggplot(aes(x = pcs_dist_out, col = zeta, fill = zeta)) +
      geom_density(alpha = 0.4) +
        facet_grid(gamma ~ ., scales = "free")

all_pcs_dists.l %>%
  mutate(colo = (gamma+1)*zeta) %>% 
    mutate(colo = factor(colo)) %>% 
  mutate(gamma = factor(gamma)) %>%
  #filter(alpha == curr_alpha) %>% 
   #mutate(component = as.factor(component), gamma = factor(gamma)) %>%
    ggplot(aes(x = pcs_dist_out, col = gamma, fill = gamma)) +
      geom_density(alpha = 0.4) +
        facet_grid(zeta ~ ., scales = "free")
        
        
```

# SBe prior:PP using ARMS

We code the pp using arms after putting the SBe prior on the locations:


```{r}

prior_predictive <- function(N, hyperparameters, n_save,rep_num){

  
 if (is.null(hyperparameters)) {
      
      hyperparameters <- list(
        sigma2_prior_shape = 3,
        sigma2_prior_rate = 2,
        alpha_prior = 0.3,
        gamma = 1,
        zeta = 1, 
        M_prior = 2
      )
      
    }else{
      
      hyperparameter_names <- c(
        "sigma2_prior_shape",
        "sigma2_prior_rate",
        "alpha_prior",
        "gamma",
        "zeta",
        "M_prior"
      )
      
      all_hyperparameters_supplied <- names(hyperparameters) %in% hyperparameter_names
      if(all(all_hyperparameters_supplied)){
        # check values
      }else{
        print(paste0("No value supplied for ", hyperparameter_names[!all_hyperparameters_supplied]))
      }
}  
 
list2env(hyperparameters, envir = .GlobalEnv)  
   
# Storage
alloc_out <- matrix(NA, n_save, N)
mu_out <- vector("list", n_save)
weights_out <- vector("list", n_save)
sigma2_out <- vector("list", n_save)
y_pred_out <- matrix(NA, n_save, N)
M_out <- rep(NA, n_save)
M_a_out <- rep(NA, n_save)
M_na_out <- rep(NA, n_save)
log_acrates_mus <- matrix(0, n_save, 50)
log_acrates_weights <- matrix(0, n_save, 50)
accepts_mus <- matrix(NA, n_save, 50)
accepts_weights <- rep(NA, n_save)
mu_sample_rate <- rep(NA, n_save)

for(iter in 1:n_save){

  # 1. Simulate the number of allocated and non-allcoated components
  M_samp <- max(1,rpois(1, M_prior))
  
  # fix to 5 to see if there are differences
  #M_samp <- 5
  
  # 2. Simulate the variances

  sigma2s_samp <- 1 / rgamma(M_samp, shape = sigma2_prior_shape, rate = sigma2_prior_rate)

  # 3. Simulate the repulsive locations
  # ARMS step for the locations
  
  mus_samp <- rnorm(M_samp, 0, 1)
  mu_start <- 0
  for(rn in 1:rep_num){
    for(p in 1:M_samp){ 
        
      mus_samp[p] <- arms(mu_start, function(x, rest_rep_locs = mus_samp[-p], z = zeta)
      - (z / 2) * x^2 + z * sum(log(cdist(x,rest_rep_locs))),
      function(x) x >  -exp(10) && x < exp(10), 1)
      
    }
  }
  # 4. Simulate the repulsive weights
  
  # Simulate by normalization of Selberg Gamma random variables
  
  #unnorm_weights_accepts <- rep(NA, M_samp)
  unnorm_weights_samp <- rgamma(M_samp, alpha_prior, 1)
  unnorm_weights_start <- 0.1
  for(rn in 1:rep_num){
    for(p in 1:M_samp){ 
        
      unnorm_weights_samp[p] <- arms(unnorm_weights_start, function(x, rest_unnorm_weights =  unnorm_weights_samp[-p], a = alpha_prior, g = gamma)
      (a - 1) * log(x) - x + 2 * g * sum(log(cdist(x, rest_unnorm_weights))),
      function(x) x > 0 && x < exp(10), 1)
      
    }
  }
  weights_samp <- unnorm_weights_samp / sum(unnorm_weights_samp)
      
  # 6. Simulate data
  
  pred_alloc <- sample(M_samp, N, prob = weights_samp, replace = TRUE)
  y_pred <- rep(NA, N)
  for(i in 1:N){
    y_pred[i] <- rnorm(1, mean = mus_samp[pred_alloc[i]], sd = sqrt(sigma2s_samp[pred_alloc[i]]))
  }

  gaps <- (1:M_samp)[!((1:M_samp) %in% pred_alloc)]
  M_na_samp <- length(gaps)
  M_a_samp <- M_samp - M_na_samp
  
  # Store draws
  M_out[iter] <- M_samp
  M_a_out[iter] <- M_a_samp
  M_na_out[iter] <- M_na_samp
  alloc_out[iter, ] <- pred_alloc
  mu_out[[iter]] <- mus_samp
  weights_out[[iter]] <- weights_samp
  sigma2_out[[iter]] <- sigma2s_samp
  y_pred_out[iter, ] <- y_pred

  if (iter %% 100 == 0) {
    print(iter)
  }
      
}

  results <- list(alloc_out = alloc_out, mu_out = mu_out, weights_out = weights_out, sigma2_out = sigma2_out,
                  y_pred_out = y_pred_out,
                  M_out = M_out, M_a_out = M_a_out, M_na_out = M_na_out,
                  accepts_weights = accepts_weights, accepts_mus = accepts_mus)
  
  return(results)

}

```

# Run

```{r, echo=FALSE, results = FALSE, message=FALSE}

n_save = 1e3
set.seed(2)

all_gammas <- c(0, 1, 3)
all_gammas <- c(0, 3, 5)
all_zetas <- c(0.01, 1, 3)
all_zetas <- c(0.01)
all_alphas <- c(0.1, 1)
#all_alphas <- c(2)
#all_gammas <- c(0)
#all_gammas <- c(0, 5)
#all_zetas <- c(0.01)
#all_zetas <- c(0.01, 5, 20)

#repulsive_grid <- expand.grid(all_gammas, all_zetas)
#colnames(repulsive_grid) <- c("gamma", "zeta")

repulsive_grid <- expand.grid(all_gammas, all_zetas, all_alphas)
colnames(repulsive_grid) <- c("gamma", "zeta", "alpha")


sigma2_prior_shape <- 3
sigma2_prior_rate <- 3
M_prior <- 3

N <- 500

all_weights.l <- data.frame()
all_mus.l <- data.frame()
all_sigma2s.l <- data.frame()
all_y_pred.l <- data.frame()
all_s_binder <- matrix(NA, length(all_gammas), N)
all_switched_allocs <- matrix(NA, length(all_gammas), N)
all_M_a.l <- data.frame()
all_M_na.l <- data.frame()
#all_M.l <- data.frame()
all_allocs.l<- data.frame()

all_weights.ls <- list()

for(i in 1:nrow(repulsive_grid)){
#for(i in 1:9){

print(paste0(i))

gamma <- repulsive_grid$gamma[i]
zeta <- repulsive_grid$zeta[i]
alpha_prior <- repulsive_grid$alpha[i]

hyperparameters <- list(sigma2_prior_shape = sigma2_prior_shape, sigma2_prior_rate = sigma2_prior_rate,
                        alpha_prior = alpha_prior,
                        gamma = gamma, zeta = zeta)

# Sample from the prior predictive

results <- prior_predictive(N, hyperparameters, n_save, rep_num = 2)


allocs.l <- data.frame(results$alloc_out)
#allocs.l$number <- 1:N
allocs.l$gamma <- gamma
allocs.l$zeta <- zeta
allocs.l$alpha <- alpha_prior
all_allocs.l <- rbind(all_allocs.l, allocs.l)

y_pred_nout <- results$y_pred_out
y_pred_out.l <- melt(y_pred_nout, varnames = c("iter", "datapoint"))
y_pred_out.l$gamma <- gamma
y_pred_out.l$zeta <- zeta
y_pred_out.l$alpha <- alpha_prior
all_y_pred.l <- rbind(all_y_pred.l, y_pred_out.l)

M_a_out.l <- data.frame(iter = 1:n_save, M_a_out = results$M_a_out)
M_a_out.l$gamma <- gamma
M_a_out.l$zeta <- zeta
M_a_out.l$alpha <- alpha_prior
all_M_a.l <- rbind(all_M_a.l, M_a_out.l)

M_na_out.l <- data.frame(iter = 1:n_save, M_na_out = results$M_na_out)
M_na_out.l$gamma <- gamma
M_na_out.l$zeta <- zeta
M_na_out.l$alpha <- alpha_prior
all_M_na.l <- rbind(all_M_na.l, M_na_out.l)


# weights

all_weights.ls[[i]] <- results$weights_out 



# Ms <- data.frame(M = results$M_a_out + results$M_na_out)
# Ms$iter <- 1:n_save
# Ms$M_na <- NA
# Ms$M_a <- NA
# for(i in 1:n_save){
#   
#   gaps <- (1:Ms$M[i])[!((1:Ms$M[i])%in% results$alloc_out[i,])]
#   Ms$M_na[i] <- length(gaps)
#   Ms$M_a[i] <- Ms$M[i] - Ms$M_na[i]
#   
# }
# M.l <- melt(Ms, id.vars = c("iter"))
# M.l$gamma <- gamma
# M.l$zeta <- zeta
# M.l$alpha <- alpha_prior
# 
# all_M.l <- rbind(all_M.l, M.l)


weights.w <- data.frame(iter = 1:n_save)
weights.w$min <- NA
weights.w$max <- NA
weights.w$mean <- NA

for(iter in 1:n_save){
  
  weights.w$max[iter] <- max(results$weights_out[[iter]])
  weights.w$min[iter] <- min(results$weights_out[[iter]])
  weights.w$mean[iter] <- mean(results$weights_out[[iter]])
  
}

weights.l <- melt(weights.w, id.vars = c("iter"))
weights.l$gamma <- gamma
weights.l$zeta <- zeta
weights.l$alpha <- alpha_prior
all_weights.l <- rbind(all_weights.l, weights.l)

mus.w <- data.frame(iter = 1:n_save)
mus.w$min <- NA
mus.w$max <- NA
mus.w$mean <- NA

for(iter in 1:n_save){
  
  mus.w$max[iter] <- max(results$mu_out[[iter]])
  mus.w$min[iter] <- min(results$mu_out[[iter]])
  mus.w$mean[iter] <- mean(results$mu_out[[iter]])
  
}

mus.l <- melt(mus.w, id.vars = c("iter"))
mus.l$gamma <- gamma
mus.l$zeta <- zeta
mus.l$alpha <- alpha_prior
all_mus.l <- rbind(all_mus.l, mus.l)


}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()

```

# Results

### M

```{r}

all_M_a.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_a_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of allocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


all_M_na.l%>%
  filter(zeta == 0.01) %>% 
  #filter(gamma %in% c(0, 5)) %>% 
  #mutate(colo = (gamma+1)*zeta) %>% 
  #mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = M_na_out, fill = gamma)) +
  geom_bar(width = 0.5, aes(y = after_stat(prop)), position = "dodge2") +
  #geom_vline(aes(xintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(alpha  ~ ., scales = "free_y") +
  ggtitle("Posterior of nonallocated components") +
  #theme(legend.position = "none")+
  xlab(expression(paste(M[a])))+
  scale_fill_npg()


Mna_trace <- all_M_na.l%>%
  mutate(colo = (gamma+1)*zeta) %>% 
  mutate(colo = factor(colo)) %>% 
  mutate(alpha = factor(alpha)) %>%
  mutate(gamma = factor(gamma)) %>%
  mutate(zeta = factor(zeta)) %>%
  ggplot(aes(x = iter, y =M_na_out, col = colo, fill = colo)) +
  geom_line() +
  #geom_hline(aes(yintercept = C), linetype="dotted", linewidth = 0.8) +
  facet_grid(zeta  ~ gamma, scales = "free_y") +
  ggtitle("Posterior of non-allocated components") +
  #theme(legend.position = "none") +
   xlab("iteration")+
  ylab(expression(paste(M[na])))+
  scale_color_npg()



```
